From 55ce4423e6ea4e3b85be0067eb78ed4d2c450391 Mon Sep 17 00:00:00 2001
From: Tamas Erdei <tamas.erdei@pan-net.eu>
Date: Tue, 3 Mar 2020 21:50:42 +0100
Subject: [PATCH 2/3] Add patches from terraform-provider-contrail

---
 ccmap.py              |    8 +
 generateDS.py         |    4 +-
 golang_api.py         |   41 +-
 terraform_mappings.py | 1509 +++++++++++++++++++++++++++++++++++++++++
 4 files changed, 1541 insertions(+), 21 deletions(-)
 create mode 100644 terraform_mappings.py

diff --git a/ccmap.py b/ccmap.py
index bc4255f..148bc88 100644
--- a/ccmap.py
+++ b/ccmap.py
@@ -12,6 +12,7 @@ from device_api import DeviceApiGenerator
 from golang_api import GoLangApiGenerator
 from json_schemagen import JsonSchemaGenerator
 from copy import deepcopy
+from terraform_mappings import TerraformMappingsGenerator
 
 
 class IFMapGenerator(object):
@@ -191,6 +192,11 @@ class IFMapGenerator(object):
                                     self._Identifiers, self._Metadata)
         apigen.Generate(self._Parser.outFilename)
 
+    def _GenerateTerraformMappings(self, xsd_root):
+        apigen = TerraformMappingsGenerator(self._Parser, self._cTypesDict,
+                                    self._Identifiers, self._Metadata)
+        apigen.Generate(self._Parser.outFilename)
+
     def _GenerateJsonSchema(self, xsd_root):
         apigen = JsonSchemaGenerator(self._Parser, self._cTypesDict,
                                   self._Identifiers, self._Metadata)
@@ -218,3 +224,5 @@ class IFMapGenerator(object):
             self._GenerateGoLangApi(root)
         elif self._genCategory == 'json-schema':
             self._GenerateJsonSchema(root)
+        elif self._genCategory == 'terraform-mappings':
+            self._GenerateTerraformMappings(root)
diff --git a/generateDS.py b/generateDS.py
index 5e47571..0a8ad5a 100755
--- a/generateDS.py
+++ b/generateDS.py
@@ -810,8 +810,9 @@ if __name__ == '__main__':
                                             'device-api',
                                             'java-api',
                                             'golang-api',
+                                            'terraform-mappings',
                                             'json-schema'):
-                    raise RuntimeError('Option --generator-category must be "type", service", "ifmap-frontend", "ifmap-backend", "device-api", "java-api", "golang-api" or "json-schema".')
+                    raise RuntimeError('Option --generator-category must be "type", service", "ifmap-frontend", "ifmap-backend", "device-api", "java-api", "golang-api, "terraform-mappings" or "json-schema".')
         if showVersion:
             print 'generateDS.py version %s' % VERSION
             sys.exit(0)
@@ -1086,6 +1087,7 @@ if __name__ == '__main__':
               self.genCategory == 'device-api' or
               self.genCategory == 'java-api' or
               self.genCategory == 'golang-api' or
+              self.genCategory == 'terraform-mappings' or
               self.genCategory == 'json-schema'):
             self._Generator = IFMapGenerator(self, self.genCategory)
         self._Generator.setLanguage(self.genLang)
diff --git a/golang_api.py b/golang_api.py
index 03d7712..02399b3 100644
--- a/golang_api.py
+++ b/golang_api.py
@@ -62,6 +62,7 @@ package types
 
 import (
         "encoding/json"
+        "math/big"
 
         "github.com/Juniper/contrail-go-api"
 )
@@ -224,7 +225,7 @@ func (obj *%(typecamel)s) Add%(fieldcamel)s(value %(ptr)s%(fieldtype)s) {
         for field in fields:
             file.write("\n\t%s_%s" % (ident.getCIdentifierName(), field))
             if first:
-                file.write(" uint64 = 1 << iota")
+                file.write(" int = iota")
                 first = False
         file.write("\n)\n")
     # end _GenerateConstFlags
@@ -268,8 +269,8 @@ type %(camel)s struct {
                    link_from.getCIdentifierName()
             file.write(decl)
 
-        decl = """        valid uint64
-        modified uint64
+        decl = """        valid big.Int
+        modified big.Int
         baseMap map[string]contrail.ReferenceList
 }
 """
@@ -329,7 +330,7 @@ func (obj *%(camel)s) hasReferenceBase(name string) bool {
 }
 
 func (obj *%(camel)s) UpdateDone() {
-        obj.modified = 0
+        obj.modified.SetInt64(0)
         obj.baseMap = nil
 }
 
@@ -351,7 +352,7 @@ func (obj *%(typecamel)s) Get%(fieldcamel)s() %(fieldtype)s {
 
 func (obj *%(typecamel)s) Set%(fieldcamel)s(value %(ptr)s%(fieldtype)s) {
         obj.%(fieldid)s = %(ptr)svalue
-        obj.modified |= %(typeid)s_%(fieldid)s
+        obj.modified.SetBit(&obj.modified, %(typeid)s_%(fieldid)s, 1)
 }
 """ \
             % {'typecamel': ident.getCppName(),
@@ -401,7 +402,7 @@ func (obj *%(typecamel)s) Set%(fieldcamel)s(value %(ptr)s%(fieldtype)s) {
         decl = """
 func (obj *%(typecamel)s) read%(fieldcamel)s%(methodsuffix)s() error {
         if !obj.IsTransient() &&
-                (obj.valid & %(typeid)s_%(fieldid)s%(suffix)s == 0) {
+                (obj.valid.Bit(%(typeid)s_%(fieldid)s%(suffix)s) == 0) {
                 err := obj.GetField(obj, "%(fieldid)s%(suffix)s")
                 if err != nil {
                         return err
@@ -463,14 +464,14 @@ func (obj *%(typecamel)s) Add%(fieldcamel)s(
                 return err
         }
 
-        if obj.modified & %(typeid)s_%(fieldid)s_refs == 0 {
+        if obj.modified.Bit(%(typeid)s_%(fieldid)s_refs) == 0 {
                 obj.storeReferenceBase("%(fieldname)s", obj.%(fieldid)s_refs)
         }
 
         ref := contrail.Reference {
                 rhs.GetFQName(), rhs.GetUuid(), rhs.GetHref(), %(data)s}
         obj.%(fieldid)s_refs = append(obj.%(fieldid)s_refs, ref)
-        obj.modified |= %(typeid)s_%(fieldid)s_refs
+        obj.modified.SetBit(&obj.modified,%(typeid)s_%(fieldid)s_refs, 1)
         return nil
 }
 
@@ -480,7 +481,7 @@ func (obj *%(typecamel)s) Delete%(fieldcamel)s(uuid string) error {
                 return err
         }
 
-        if obj.modified & %(typeid)s_%(fieldid)s_refs == 0 {
+        if obj.modified.Bit(%(typeid)s_%(fieldid)s_refs) == 0 {
                 obj.storeReferenceBase("%(fieldname)s", obj.%(fieldid)s_refs)
         }
 
@@ -492,18 +493,18 @@ func (obj *%(typecamel)s) Delete%(fieldcamel)s(uuid string) error {
                         break
                 }
         }
-        obj.modified |= %(typeid)s_%(fieldid)s_refs
+        obj.modified.SetBit(&obj.modified, %(typeid)s_%(fieldid)s_refs, 1)
         return nil
 }
 
 func (obj *%(typecamel)s) Clear%(fieldcamel)s() {
-        if (obj.valid & %(typeid)s_%(fieldid)s_refs != 0) &&
-           (obj.modified & %(typeid)s_%(fieldid)s_refs == 0) {
+        if (obj.valid.Bit(%(typeid)s_%(fieldid)s_refs) != 0) &&
+           (obj.modified.Bit(%(typeid)s_%(fieldid)s_refs) == 0) {
                 obj.storeReferenceBase("%(fieldname)s", obj.%(fieldid)s_refs)
         }
         obj.%(fieldid)s_refs = make([]contrail.Reference, 0)
-        obj.valid |= %(typeid)s_%(fieldid)s_refs
-        obj.modified |= %(typeid)s_%(fieldid)s_refs
+        obj.valid.SetBit(&obj.valid, %(typeid)s_%(fieldid)s_refs, 1)
+        obj.modified.SetBit(&obj.modified, %(typeid)s_%(fieldid)s_refs, 1)
 }
 
 func (obj *%(typecamel)s) Set%(fieldcamel)sList(
@@ -546,7 +547,7 @@ func (obj *%(camel)s) MarshalJSON() ([]byte, error) {
 
         for prop in ident.getProperties():
             decl = """
-        if obj.modified & %(typeid)s_%(fieldid)s != 0 {
+        if obj.modified.Bit(%(typeid)s_%(fieldid)s) != 0 {
                 var value json.RawMessage
                 value, err := json.Marshal(&obj.%(fieldid)s)
                 if err != nil {
@@ -630,7 +631,7 @@ func (obj *%(camel)s) UnmarshalJSON(body []byte) error {
                 case "%(field)s":
                         err = json.Unmarshal(value, &obj.%(field)s)
                         if err == nil {
-                                obj.valid |= %(typeid)s_%(field)s
+                                obj.valid.SetBit(&obj.valid, %(typeid)s_%(field)s, 1)
                         }
                         break""" % {'typeid': ident.getCIdentifierName(),
                                     'field': field}
@@ -650,7 +651,7 @@ func (obj *%(camel)s) UnmarshalJSON(body []byte) error {
                         if err != nil {
                             break
                         }
-                        obj.valid |= %(typeid)s_%(field)s
+                        obj.valid.SetBit(&obj.valid, %(typeid)s_%(field)s, 1)
                         obj.%(field)s = make(contrail.ReferenceList, 0)
                         for _, element := range array {
                                 ref := contrail.Reference {
@@ -694,7 +695,7 @@ func (obj *%(camel)s) UpdateObject() ([]byte, error) {
 
         for prop in ident.getProperties():
             decl = """
-        if obj.modified & %(typeid)s_%(fieldid)s != 0 {
+        if obj.modified.Bit(%(typeid)s_%(fieldid)s) != 0 {
                 var value json.RawMessage
                 value, err := json.Marshal(&obj.%(fieldid)s)
                 if err != nil {
@@ -712,7 +713,7 @@ func (obj *%(camel)s) UpdateObject() ([]byte, error) {
                 continue
             link_to = ident.getLinkTo(link_info)
             decl = """
-        if obj.modified & %(typeid)s_%(fieldid)s_refs != 0 {
+        if obj.modified.Bit(%(typeid)s_%(fieldid)s_refs) != 0 {
                 if len(obj.%(fieldid)s_refs) == 0 {
                         var value json.RawMessage
                         value, err := json.Marshal(
@@ -760,7 +761,7 @@ func (obj *%(camel)s) UpdateReferences() error {
                 continue
             link_to = ident.getLinkTo(link_info)
             decl = """
-        if (obj.modified & %(typeid)s_%(fieldid)s_refs != 0) &&
+        if (obj.modified.Bit(%(typeid)s_%(fieldid)s_refs) != 0) &&
            len(obj.%(fieldid)s_refs) > 0 &&
            obj.hasReferenceBase("%(fieldname)s") {
                 err := obj.UpdateReference(
diff --git a/terraform_mappings.py b/terraform_mappings.py
new file mode 100644
index 0000000..669f4e9
--- /dev/null
+++ b/terraform_mappings.py
@@ -0,0 +1,1509 @@
+#
+# Copyright (c) 2013 Juniper Networks, Inc. All rights reserved.
+#
+
+import os
+import sys
+
+from ifmap_global import CamelCase, getGoLangType
+from ifmap_model import IFMapLink
+
+
+def udump(obj, depth=0, max_depth=10):
+    #print "called udump: " + str(type(obj)) + "->" + str(obj) + "[" + str(depth) +"/" + str(max_depth) +"]"
+    prefix = '\t'*depth
+    if depth > max_depth:
+        return '...'
+    if obj is None:
+        return 'None'
+
+    if isinstance(obj, dict):
+        data = '{' + ','.join( \
+            ["(%s => %s)" %(str(k), dump(v)) for (k, v) in obj.items()]) + '}'
+        return data
+    elif hasattr(obj, "_ast"):
+        return prefix + udump(obj._ast(), max_depth=max_depth)
+    elif hasattr(obj, "__iter__"):
+        return "[" + " ### ".join([udump(v, depth=depth+1, max_depth=max_depth) for v in obj]) + "]"
+    elif ( hasattr(obj, "__dir__") and callable(getattr(obj, "__dir__")) ) or \
+            hasattr(obj, "__dict__"):
+        objstr = "%s ~ " % str(obj)
+        for attr in dir(obj):
+            if attr.startswith("__"):
+                continue
+            attrvalue = getattr(obj, attr)
+            if callable(attrvalue):
+                objstr += '\n' + prefix + "&METHOD:"+str(attrvalue)+"()"
+            else:
+                objstr += ('\n' + prefix + "@.%s = %s; " % (attr, attrvalue if depth == max_depth
+                                        else udump(attrvalue, depth=depth+1,
+                                                   max_depth=max_depth) ))
+        return objstr
+    elif type(obj).__name__ in dir(__builtins__):
+        return str(obj)
+    else:
+        return prefix + dump(obj)
+
+def dump(obj):
+    objstr = "(%s -> " % str(obj)
+    for attr in dir(obj):
+        if attr.startswith('__'):
+            continue
+        attrvalue = getattr(obj, attr)
+        objstr += ("@.%s = %s; " % (attr, attrvalue))
+    return objstr
+
+def ResolveOptional(val):
+    if val is None:
+        req = False
+    elif str(val).lower() == 'required':
+        req = True
+    elif str(val).lower() == 'true':
+        req = True
+    elif str(val).lower() == 'false':
+        req = False
+    elif str(val).lower() == 'optional':
+        req = False
+    elif str(val).lower() == 'exclusive':
+        req = False # Only one of values need to exist
+    elif str(val).lower() == 'system-only':
+        req = False
+    else:
+        req = False
+    return req
+
+
+def ResName(name):
+    return "Resource" + name
+
+def SchemaName(name):
+    return ResName(name) + "Schema"
+
+def TerraformTypeName(name, orig_name=False):
+    default = 'schema.TypeList' if orig_name == False else name
+    return {
+        'string': 'schema.TypeString',
+        'int': 'schema.TypeInt',
+        'uint64': 'schema.TypeInt',
+        'bool': 'schema.TypeBool',
+        'float32': 'schema.TypeFloat',
+        'float64': 'schema.TypeFloat',
+        'xsd:string': 'schema.TypeString',
+        'xsd:integer': 'schema.TypeInt',
+        'xsd:unsignedInt': 'schema.TypeInt',
+        'xsd:boolean': 'schema.TypeBool',
+        'xsd:unsignedLong' : 'schema.TypeInt',
+        'xsd:dateTime': 'schema.TypeString',
+        'xsd:time': 'schema.TypeInt',
+    }.get(name, default)
+
+def IsPodType(name):
+    return not name == TerraformTypeName(name, orig_name=True)
+
+# ------------------- Terraform mappings Class -------------------------------
+class TerraformMappingsGenerator(object):
+    _NAME = "contrail"
+    @property
+    def NAME(self):
+        return type(self)._NAME
+
+    def __init__(self, parser, type_map, identifiers, metadata):
+        self._parser = parser
+        self._type_map = type_map
+        self._metadata_map = metadata
+        self._top_level_map = {}
+        self._ctype_docs = set()
+        self._type_count = {}
+        self._identifier_map = identifiers
+
+    def _SnippetGetClient(self):
+        return "client := m.(*contrail.Client)\n"\
+            "client.GetServer() // dummy call"
+
+    def _SnippetProviderResource(self, ident, suffix=""):
+        resname = (ident.getCIdentifierName() + (('_' + suffix) if len(suffix)
+                   else '')).lower()
+        decl = '\t"%(provider)s_%(name)s": %(res)s(),\n' % {
+            "name": resname,
+            "res": ResName(ident.getCppName() + suffix),
+            "provider": self.NAME}
+        return decl
+
+# ------------------- Generate resources map -------------------------------
+    def _GenerateTypeMap(self, dirname):
+        file = self._parser.makeFile(os.path.join(dirname, 'types.go'))
+        decl = """
+// Automatically generated. DO NOT EDIT.
+// (Type Map)
+//
+
+package resources
+
+import (
+    "github.com/hashicorp/terraform/helper/schema"
+    "log"
+)
+
+var _ = log.Printf // Avoid import errors if not used
+
+var ContrailResourcesMap = map[string]*schema.Resource{
+"""
+        file.write(decl)
+        for ident in sorted(self._identifier_map.values(),
+                            key=lambda x: x.getCIdentifierName()):
+            file.write(self._SnippetProviderResource(ident))
+            if self._RefsNeeded(ident):
+                file.write(self._SnippetProviderResource(ident, "Refs"))
+        file.write("\n}\n")
+        decl = """
+func CheckTerraformMap(x interface{}) bool {
+    //log.Printf("Checking %T => %#v", x, x)
+    slice, ok := x.([]interface{})
+    if ok && len(slice) > 0 {
+        return true
+    }
+    switch x.(type) {
+        case int8: return true
+        case int16: return true
+        case int32: return true
+        case int64: return true
+        case uint: return true
+        case uint8: return true
+        case uint16: return true
+        case uint32: return true
+        case uint64: return true
+        case bool: return true
+        case float32: return true
+        case float64: return true
+        case string: return true
+        case int: return true
+    }
+    return false
+}
+"""
+        file.write(decl)
+
+# ------------------- Generate resources docs -------------------------------
+    def _GenerateDocfile(self, dirname):
+        file = self._parser.makeFile(os.path.join(dirname, 'reference.txt'))
+        decl = """
+Reference for terraform_%s_provider resources schema:
+
+""" % self.NAME
+        file.write(decl)
+        # Object
+        for ident in sorted(self._identifier_map.values(),
+                            key=lambda x: x.getCIdentifierName()):
+            iname = ident.getCIdentifierName().lower()
+            decl = 'resource "%(provider)s_%(name)s" <name> {' % {
+                "name": iname,
+                "provider": self.NAME}
+            file.write(decl)
+            self._GenerateResourceDocfile(ident, file)
+            file.write('}\n')
+            if self._RefsNeeded(ident):
+                decl = 'resource "%(prv)s_%(name)s_refs" <name> {' % {
+                    "name": iname, "prv": self.NAME}
+                file.write(decl)
+                self._GenerateResourceRefDocfile(ident, file)
+                file.write('}\n')
+
+        # CType
+        for ctype in sorted(self._top_level_map.values(),
+                            key=lambda x: x.getCIdentifierName()):
+            for deptype in ctype.getDependentTypes():
+                self._GenerateCTypeDocs(deptype, file)
+            self._GenerateCTypeDocs(ctype, file)
+
+# ------------------- Object docs -------------------------------
+    def _GenerateResourceDocfile(self, ident, file):
+        decl = """
+\tname = <schema.TypeString>
+\tparent_uuid = <schema.TypeString> // If not set, default parent will be used
+"""
+        file.write(decl)
+        for prop in [v for v in ident.getProperties() if v.getName() != ("%s-%s" % (ident.getName(), "id"))]:
+            prop_type = TerraformTypeName(prop.getGoLangTypename())
+            if prop_type == "schema.TypeList":
+                prop_type = 'contrail_' + prop.getGoLangTypename()
+            descr = prop._xelement.description
+            elem = '\t%(name)s = <%(type)s>%(opt)s%(desc)s\n' % {
+                "name": prop.getCIdentifierName(),
+                "type": prop_type,
+                "opt": " (Required)" if ResolveOptional(
+                    prop._xelement.getOptional()) else '',
+                "desc": ' // ' + descr if descr is not None else ""}
+            file.write(elem)
+
+    def _GenerateResourceRefDocfile(self, ident, file):
+        decl = """
+\tuuid = <schema.TypeString> // uuid of "contrail_%(name)s" object to attach refs
+%(refs)s""" % {"name": ident.getCIdentifierName().lower(), "refs":
+               self._SnippetRefsDocs(ident)}
+        file.write(decl)
+
+    def _SnippetRefsDocs(self, ident):
+        decl = '\t'
+        for link_info in ident.getLinksInfo():
+            if not ident.isLinkRef(link_info):
+                continue
+            decl += self._SnippetRefModifiersDocs(ident, link_info) + '\n'
+        return '\t'.join(decl.splitlines(True))
+
+    def _SnippetRefModifiersDocs(self, ident, link_info):
+        datatype = self._getAttrType(ident, link_info)
+        link_to = ident.getLinkTo(link_info)
+        name = link_to.getCIdentifierName().lower()
+        elem = '= <contrail_%s>' % link_to.getCppName()
+        if datatype:
+            elem = """{
+\tto = <schema.TypeString> (Required) // uuid of contrail_%(totype)s ref target
+\tattr = <contrail_%(datatype)s> (Required) // ref link attribute data
+}""" % {"totype": name, "datatype": datatype}
+        decl = "%(name)s_refs %(elem)s" % {"name": name, "elem": elem}
+        return decl
+
+# ------------------- CType docs -------------------------------
+    def _GenerateCTypeResourceDocfile(self, ctype, file):
+        for member in ctype.getDataMembers():
+            mtype = TerraformTypeName(
+                member.xsd_object.getType(), orig_name=True)
+            if not mtype.startswith('schema.'):
+                mtype = 'contrail_' + mtype
+            if member.isSequence:
+                mtype = ' [ %s ] ' % mtype
+            descr = member.xsd_object.description
+            elem = '\n\t"%(name)s" = <%(type)s>%(opt)s%(desc)s' % {
+                'name': member.membername.lower(),
+                'type': mtype,
+                'opt': ' (Required)' if ResolveOptional(
+                    member.xsd_object.required) else '',
+                "desc": ' // ' + descr if descr is not None else ""}
+            file.write(elem)
+
+# ------------------- CType snippet docs -------------------------------
+    def _GenerateCTypeDocs(self, ctype, file):
+        if ctype.getName() in self._ctype_docs:
+            return
+        self._ctype_docs.add(ctype.getName())
+        decl = '%(provider)s_%(name)s {' % {
+            "name": ctype.getName(),
+            "provider": self.NAME}
+        file.write(decl)
+        self._GenerateCTypeResourceDocfile(ctype, file)
+        file.write('\n}\n')
+
+    def _RefsNeeded(self, ident):
+        for link_info in ident.getLinksInfo():
+            if not ident.isLinkRef(link_info):
+                continue
+            return True
+        return False
+
+# ------------------- Object -------------------------------
+    def _GenerateObject(self, ident, filename):
+        """ Generate the class corresponding to an IF-MAP Identifier
+        defined in the schema.
+        """
+        fields = [prop.getCIdentifierName() for prop in ident.getProperties()]
+        fields.extend(self._IdentifierLinks(ident))
+        # Normalize names for terraform resources
+        # Terraform requires resource names as:
+        # 'only contain lowercase alphanumeric characters & underscores.'
+        file = self._parser.makeFile(filename)
+
+        header = """//
+// Automatically generated. DO NOT EDIT.
+// (Object)
+//
+
+package resources
+
+import (
+        "fmt"
+        "strings"
+        "log"
+
+        "github.com/hashicorp/terraform/helper/schema"
+        "github.com/Juniper/contrail-go-api"
+        "github.com/davecgh/go-spew/spew"
+)
+
+var _ = spew.Dump // Avoid import errors if not used
+
+"""
+        file.write(header)
+        need_refs = self._RefsNeeded(ident)
+        self._GenerateTerraformResourceSetFrom(ident, file)
+        self._GenerateTerraformResourceDeleteFrom(ident, file)
+        self._GenerateTerraformResourceWriteTo(ident, file)
+        self._GenerateTerraformResourceUpdateFrom(ident, file)
+        self._GenerateTerraformResourceCreate(ident, need_refs, file)
+        self._GenerateTerraformResourceRead(ident, need_refs, file)
+        self._GenerateTerraformResourceUpdate(ident, need_refs, file)
+        self._GenerateTerraformResourceDelete(ident, need_refs, file)
+        self._GenerateTerraformResource(ident, need_refs, file)
+
+# ------------------- Struct Type Header -------------------------------
+    def _GenerateStructType(self, ctype, filename):
+        file = self._parser.makeFile(filename)
+        header = """//
+// Automatically generated. DO NOT EDIT.
+// (Struct Type [aka CType])
+//
+
+package resources
+
+import (
+        "github.com/hashicorp/terraform/helper/schema"
+        "github.com/davecgh/go-spew/spew"
+
+        "log"
+)
+var _ = spew.Dump // Avoid import errors if not used
+"""
+        file.write(header)
+        self._GenerateCType(ctype, file)
+
+# ------------------- Struct Type -------------------------------
+    def _GenerateCType(self, ctype, file):
+        for deptype in ctype.getDependentTypes():
+            if deptype.getName() in self._top_level_map:
+                continue
+            self._GenerateCType(deptype, file)
+        self._GenerateCTypeTerraformMapSetFrom(ctype, file)
+        self._GenerateCTypeTerraformResourceWriteTo(ctype, file)
+        # self._GenerateCTypeTerraformResourceRead(ctype, file)
+        self._GenerateCTypeTerraformResource(ctype, file)
+        # mark as generated
+        ctypename = ctype.getName()
+        self._top_level_map[ctypename] = self._type_map[ctypename]
+
+# ------------------- Schema CType -------------------------------
+    def _GenerateCTypeTerraformResourceSchema(self, ctype, file):
+        decl = """
+func %(camel)s() map[string]*schema.Schema {
+\treturn map[string]*schema.Schema{
+""" % {'camel': SchemaName(ctype.getName())}
+        file.write(decl)
+
+        for member in ctype.getDataMembers():
+            elem = ""
+            required = "Required: true" if \
+                ResolveOptional(member.xsd_object.required) \
+                else "Optional: true"
+            mtype = TerraformTypeName(member.xsd_object.getType(),
+                                          orig_name = True)
+            if member.isComplex or member.isSequence:
+                if member.isComplex:
+                    elem = "\n\t\t\tElem: %s," % (ResName(mtype) + "()")
+                elif member.isSequence:
+                    elem = "\n\t\t\tElem: &schema.Schema{Type: %s}," % (mtype)
+                mtype = 'schema.TypeList'
+
+            decl = """\t\t"%(name)s": &schema.Schema{
+\t\t\t // Cmplx: %(cpx)s; Seq: %(seq)s; Type: %(xsdtype)s
+\t\t\t%(req)s,
+\t\t\tType: %(type)s,%(elem)s
+\t\t},\n""" % {'name': member.membername.lower(), 'type': mtype, 'elem': elem,
+               'cpx': member.isComplex, 'seq': member.isSequence, 'xsdtype':
+               member.xsd_object.getType(),
+               "req": required}
+            file.write(decl)
+        file.write('\t}\n}\n')
+
+# ------------------- Properties Resource Setter CType -------------------------------
+    def _GenerateCTypeResourceSetPropertyMethods(self, ctype):
+        setters = ""
+        for member in ctype.getDataMembers():
+            origtype = member.xsd_object.getType()
+            gotype = getGoLangType(origtype)
+            is_pod = IsPodType(gotype)
+            setme = "\tobject.%s = val.(%s)" % (
+                CamelCase(member.membername), gotype)
+            obj = ""
+            val = "val"
+            if not is_pod:
+                obj = "\tmember := new(%s)\n" % origtype
+                setme = "\tSet%(type)sFromMap(member, d, m, val)" % {
+                    "type": origtype, "name": member.membername}
+            if member.isSequence:
+                obj = ""
+                if not is_pod:
+                    gotype = "*"+origtype
+                setme = """\tfor _, v := range val.([]interface{}) {
+\t\tobject.Add%(member)s(v.(%(gotype)s))
+\t}""" % { "gotype": gotype, "member": CamelCase(member.membername) }
+            if not is_pod and not member.isSequence:
+                # val = "_"
+                pass
+            decl = """
+\tif d != nil {
+\t\tfullKey := key+"%(name)s"
+\t\tval, ok := d.GetOk(fullKey)
+\t\tlog.Printf("GetOk -- (nested) KEY+NAME(%%v): %%v -- val: %%#v", fullKey, ok, val)
+\t\tpkey := key[:len(key)-1]
+\t\tvaln, okn := d.GetOk(pkey)
+\t\tlog.Printf("GET PREFIX  -- '%%v': %%v -- val: %%#v", pkey, okn, valn)
+\t}
+
+\tif %(val)s, ok := d.GetOk(key+"%(name)s"); ok {
+%(member_obj)s%(setme)s
+}\n""" % {"name": member.membername, "member_obj": obj, "setme": setme,
+          "val": val}
+            setters += decl
+        return setters
+
+# ------------------- Properties Map Setter CType -------------------------------
+    def _GenerateCTypeMapSetPropertyMethods(self, ctype):
+        setters = ""
+        for member in ctype.getDataMembers():
+            origtype = member.xsd_object.getType()
+            is_pod = IsPodType(getGoLangType(origtype))
+            is_seq = member.isSequence
+            gotype = getGoLangType(origtype) if is_pod else origtype
+            name = member.membername
+            camel = CamelCase(name)
+            obj = "" if is_pod else "\tm%s := new(%s)\n" % (camel, gotype)
+            assign = ("\t\tobject.Add%(c)s(m%(c)s)\n" % {"c": camel}) if \
+                is_seq else "\tobject.%(c)s = m%(c)s\n" % {"c": camel}
+            convert = "\tm%(c)s := m%(c)sObj.(%(t)s)\n" % {
+                "c": camel, "t": gotype}
+            loop = loopEnd = ""
+            src = ("m%s" % camel) if is_pod else ("m%sObj" % camel)
+
+            if is_seq:
+                src = "v"
+                loop = "\tfor _, v := range m%sObj.([]interface{}) {\n" % camel
+                convert = "\t\tm%s := v.(%s)\n" % (camel, gotype)
+                loopEnd = "\t}\n"
+            if not is_pod:  # if COMPLEX type
+                convert = "\tSet%(type)sFromMap(m%(c)s, d, m, %(src)s)\n"\
+                    % {"type": origtype, "c": camel, "src": src}
+            setme = "%s%s%s%s%s" % (loop, obj, convert, assign, loopEnd)
+            decl = """
+\tm%(camel)sObj := vmap["%(name)s"] // [CPLX; Seq -> %(cpx)s; %(seq)s]
+\tif CheckTerraformMap(m%(camel)sObj) {
+\t\tlog.Printf("Setting %(name)s  %(camel)s <<%%T>> => %%#v", m%(camel)sObj, m%(camel)sObj)
+%(setme)s\t}
+""" % {"name": name, "setme": setme,
+                          "mtype": "NOT-NEEDED", "camel": camel,
+                          "cpx": "1" if member.isComplex else "0",
+                          "seq": "1" if member.isSequence else "0"}
+            setters += decl
+        return setters
+
+# ------------------- Set From Map CType -------------------------------
+    def _GenerateCTypeTerraformMapSetFrom(self, ctype, file):
+        decl = """
+func Set%(camel)sFromMap(object *%(name)s, d *schema.ResourceData, m interface{}, val interface{}) {
+\tlog.Printf("[Set%(camel)sFromMAP] map = %%#v", val)
+
+\tvmap, ok := val.(map[string]interface{});
+\tif ok == false {
+\t\tvmap = (val.([]interface{})[0]).(map[string]interface{})
+\t}
+
+\t// SPEW
+\tlog.Printf("SPEW: %%v", spew.Sdump(vmap))
+\t// SPEW
+
+%(setters)s
+\tlog.Printf("FINISHED %(camel)s object: %%#v", object)
+}
+""" %{"camel": ctype.getName(), "setters":
+      '\t'.join(self._GenerateCTypeMapSetPropertyMethods(ctype).splitlines(True)),
+      "name": ctype.getName()}
+        file.write(decl)
+
+# ------------------- Properties Writer CType -------------------------------
+    def _GenerateCTypeMapPropertyMethods(self, ctype):
+        writers = "\n"
+        for member in ctype.getDataMembers():
+            origtype = member.xsd_object.getType()
+            gotype = getGoLangType(origtype)
+            is_pod = IsPodType(gotype)
+            field = CamelCase(member.membername)
+            setter = "omap[\"%(name)s\"] = object.%(field)s\n" % {
+                "name": member.membername, "field": field}
+            ttype = TerraformTypeName(origtype, orig_name=True)
+            if member.isSequence:
+                setter = """%(name)s_arr := make([]%(gotype)s, len(object.%(field)s))
+for _, v := range object.%(field)s {
+\t%(name)s_arr = append(%(name)s_arr, v)
+}
+omap[\"%(name)s\"] = %(name)s_arr\n""" % {
+                    "gotype": gotype,
+                    "field": field, "ttype": ttype,
+                    "name": member.membername}
+            if not is_pod:  # COMPLEX type
+                setter = """if object.%(member)s != nil {
+\tomap["%(name)s"] = Take%(type)sAsMap(object.%(member)s)
+}
+""" % \
+                    {"name": member.membername,
+                     "type": origtype, "member": field}
+                if member.isSequence:  # Complex Sequence
+                    setter = """var %(name)s_map []interface{}
+// COMPLEX SEQUENCE
+for _, v := range object.%(field)s {
+\t%(name)s_map = append(%(name)s_map, Take%(type)sAsMap(&v))
+}
+omap[\"%(name)s\"] = %(name)s_map
+""" % {"field": field, "name": member.membername, "gotype": gotype,
+                       "type": origtype}
+            writers += setter
+        return writers
+
+# ------------------- Write To Resource CType -------------------------------
+    def _GenerateCTypeTerraformResourceWriteTo(self, ctype, file):
+        decl = """
+func Take%(name)sAsMap(object *%(name)s) map[string]interface{} {
+\tomap := make(map[string]interface{})
+%(writers)s
+\treturn omap
+}
+""" % \
+            {"client": self._SnippetGetClient(),
+             "writers": '\t'.join(self._GenerateCTypeMapPropertyMethods(
+                 ctype).splitlines(True)), "name": ctype.getName()}
+        file.write(decl)
+
+# ------------------- Resource CType -------------------------------
+    def _GenerateCTypeTerraformResource(self, ctype, file):
+        self._GenerateCTypeTerraformResourceSchema(ctype, file)
+
+        decl = """
+func %(camel)s() *schema.Resource {
+\treturn &schema.Resource{
+\t\tSchema: %(camel)sSchema(),
+\t}
+}
+""" % {"camel": ResName(ctype.getName())}
+        file.write(decl)
+
+# ------------------- Create CType -------------------------------
+    def _GenerateCTypeTerraformResourceCreate(self, ctype, file):
+        decl = """
+func %(camel)sCreate(d *schema.ResourceData, m interface{}) error {
+\tlog.Printf("%(camel)sCreate")
+\t%(client)s
+\tobject := new(%(name)s)
+\tif err := client.Create(object); err != nil {
+\t\treturn fmt.Errorf("[%(camel)sCreate] Creation of resource %(name)s on %%v: (%%v)", client.GetServer(), err)
+\t}
+\td.SetId(object.GetUuid())
+\treturn nil
+}
+""" % {"camel": ResName(ctype.getName()), "client": self._SnippetGetClient(),
+       "name": ctype.getName()}
+        file.write(decl)
+
+# ------------------- Read CType -------------------------------
+    def _GenerateCTypeTerraformResourceRead(self, ctype, file):
+        decl = """
+func %(camel)sRead(d *schema.ResourceData, m interface{}) error {
+\tlog.Printf("%(camel)sREAD")
+\t%(client)s
+\treturn nil
+}
+""" % {"camel": ResName(ctype.getName()), "client": self._SnippetGetClient()}
+        file.write(decl)
+
+# ------------------- Update CType -------------------------------
+    def _GenerateCTypeTerraformResourceUpdate(self, ctype, file):
+        decl = """
+func %(camel)sUpdate(d *schema.ResourceData, m interface{}) error {
+\tlog.Printf("%(camel)sUpdate")
+\t%(client)s
+\treturn nil
+}
+""" % {"camel": ResName(ctype.getName()), "client": self._SnippetGetClient()}
+        file.write(decl)
+
+# ------------------- Delete CType -------------------------------
+    def _GenerateCTypeTerraformResourceDelete(self, ctype, file):
+        decl = """
+func %(camel)sDelete(d *schema.ResourceData, m interface{}) error {
+\tlog.Printf("%(camel)sDelete: %%v", d.Id())
+\t%(client)s
+\treturn nil
+}
+""" % {"camel": ResName(ctype.getName()), "client": self._SnippetGetClient()}
+        file.write(decl)
+
+# ------------------- Resource Object -------------------------------
+    def _GenerateTerraformResource(self, ident, need_refs, file):
+        self._GenerateTerraformResourceSchema(ident, need_refs, file)
+        decl = """
+func %(camel)s() *schema.Resource {
+\treturn &schema.Resource{
+\t\tCreate: %(camel)sCreate,
+\t\tRead: %(camel)sRead,
+\t\tUpdate: %(camel)sUpdate,
+\t\tDelete: %(camel)sDelete,
+\t\tSchema: %(camel)sSchema(),
+\t}
+}
+""" % {"camel": ResName(ident.getCppName())}
+        file.write(decl)
+        decl = """
+func %(camel)sRefs() *schema.Resource {
+\treturn &schema.Resource{
+\t\tCreate: %(camel)sRefsCreate,
+\t\tRead: %(camel)sRefsRead,
+\t\tUpdate: %(camel)sRefsUpdate,
+\t\tDelete: %(camel)sRefsDelete,
+\t\tSchema: %(camel)sRefsSchema(),
+\t}
+}
+""" % {"camel": ResName(ident.getCppName())}
+        if need_refs:
+            file.write(decl)
+
+# ------------------- Schema Object -------------------------------
+    def _GenerateTerraformResourceSchema(self, ident, need_refs, file):
+        """Generate the terraform element schema.
+
+        Use prop.getOperations() to determine possible acions (CRUD)
+        """
+        # Set references CTypes as referenced
+        for link_info in ident.getLinksInfo():
+            if not ident.isLinkHas(link_info):
+                datatype = self._getAttrType(ident, link_info)
+                if datatype:
+                    self._top_level_map[datatype] = self._type_map[datatype]
+
+        # TODO(KR) Use prop.getOperations() to determine possible CRUD actions
+        decl = """
+func %(schema)s() map[string]*schema.Schema {
+\treturn map[string]*schema.Schema{
+\t\t"name": &schema.Schema{
+\t\t\tType: schema.TypeString,
+\t\t\tRequired: true,
+\t\t},
+\t\t"parent_uuid": &schema.Schema{
+\t\t\tType: schema.TypeString,
+\t\t\tOptional: true,
+\t\t},
+""" % {"schema": SchemaName(ident.getCppName())}
+        file.write(decl)
+
+        file.write("\t// Properties\n")
+        for prop in [v for v in ident.getProperties() if v.getName() != ("%s-%s" % (ident.getName(), "id"))]:
+            # Mark CType as referenced
+            ctype = prop.getCType()
+            if ctype:
+                ctypename = ctype.getName()
+                self._top_level_map[ctypename] = self._type_map[ctypename]
+
+            prop_type = TerraformTypeName(prop.getGoLangTypename())
+            required = "Required: true" if \
+                ResolveOptional(prop._xelement.getOptional()) \
+                else "Optional: true"
+            elem = ''
+            if prop_type == "schema.TypeList":
+                elem = '\t\t\tElem: ' + ResName(prop.getGoLangTypename()) +\
+                    "(),\n"
+            decl = """\t\t"%(name)s": &schema.Schema{
+\t\t\t%(req)s,
+\t\t\tType: %(type)s,
+%(elem)s\t\t},\n""" % {"name": prop.getCIdentifierName().lower(),
+                       "type": prop_type, "elem": elem,
+                       "req": required}
+
+            file.write(decl)
+
+        if need_refs:
+            refs = self._SnippetRefsMethods(ident, file, True)
+            file.write(refs)
+
+        file.write("\t}\n}\n")
+
+        # Refs
+        decl = """
+func %(schema)s() map[string]*schema.Schema {
+\treturn map[string]*schema.Schema{
+\t\t"uuid": &schema.Schema{
+\t\t\tType: schema.TypeString,
+\t\t\tRequired: true,
+\t\t},
+""" % {"schema": SchemaName(ident.getCppName() + "Refs")}
+        refs = self._SnippetRefsMethods(ident, file, False)
+        if need_refs:
+            file.write(decl)
+            file.write(refs)
+            file.write("\t}\n}\n")
+
+# ------------------- Refs Schema Object --------------------------
+    def _SnippetRefsMethods(self, ident, file, req):
+        decl = ""
+        for link_info in ident.getLinksInfo():
+            if not ident.isLinkRef(link_info):
+                continue
+            required = False
+            for info in link_info:
+                if isinstance(info, IFMapLink):
+                    required = ResolveOptional(info.getPresence())
+
+            if req == required:
+                decl += self._SnippetRefModifiers(ident, link_info)
+        return decl
+
+    def _getAttrType(self, ident, link_info):
+        xlink = ident.getLink(link_info)
+        if xlink.getXsdType():
+            ctype = xlink.getCType()
+            if ctype is not None:
+                return ctype.getName()
+        return None
+
+# ------------------- BackRefs Schema Object --------------------------
+    def _GenerateBackRefsMethods(self, ident, file):
+        for back_link in ident.getBackLinksInfo():
+            link_from = ident.getBackLinkFrom(back_link)
+
+# ------------------- Snippet method suffix - refs --------------------------
+    def _SnippetMethodSuffix(self, suffix):
+        expr = re.compile(r'_([a-z])')
+        return expr.sub(lambda x: x.group(1).upper(), suffix)
+
+# ------------------- Snippet Refs Accessor Object --------------------------
+    def _SnippetRefModifiers(self, ident, link_info):
+        datatype = self._getAttrType(ident, link_info)
+        link_to = ident.getLinkTo(link_info)
+
+
+        name = link_to.getCIdentifierName().lower()
+
+        if datatype:
+            elem = """&schema.Resource{
+\t\t\t\tSchema: map[string]*schema.Schema{
+\t\t\t\t\t"to": &schema.Schema{
+\t\t\t\t\t\tType: schema.TypeString,
+\t\t\t\t\t\tRequired: true,
+\t\t\t\t\t},
+\t\t\t\t\t"attr": &schema.Schema{
+\t\t\t\t\t\tType: schema.TypeList,
+\t\t\t\t\t\tElem: Resource%(datatype)s(),
+\t\t\t\t\t\tRequired: true,
+\t\t\t\t\t},
+\t\t\t\t},
+\t\t\t}""" % {"datatype": datatype}
+        else:
+            elem = """&schema.Resource{
+    \t\t\t\tSchema: map[string]*schema.Schema{
+    \t\t\t\t\t"to": &schema.Schema{
+    \t\t\t\t\t\tType: schema.TypeString,
+    \t\t\t\t\t\tRequired: true,
+    \t\t\t\t\t},
+    \t\t\t\t},
+    \t\t\t}"""
+        return """\t\t"%(name)s_refs": &schema.Schema{
+\t\t\tOptional: true,
+\t\t\tType: schema.TypeList,
+\t\t\tElem: %(elem)s,
+\t\t},\n""" % {"name": name, "elem": elem}
+
+
+# ------------------- Property Setter Snippet Object --------------------------
+    def _SnippetSetObjProperty(self, ident_name, prop):
+        decl = ""
+        if ("%s-%s" % (ident_name, "id")) != prop.getName():
+            gotype = prop.getGoLangTypename()
+            is_pod = IsPodType(gotype)
+            value = "val.(%(type)s)" % {"type": gotype}
+            obj = ""
+            val = "val"
+            if not is_pod:
+                obj = "\tmember := new(%(type)s)\n\tSet%(type)sFromMap(member, d, m, (val.([]interface{}))[0])\n" %\
+                    {"type": gotype, "name": prop.getCIdentifierName().lower()}
+                value = "member"
+            decl = """if %(val)s, ok := d.GetOk("%(name)s"); ok {
+    %(member_obj)s\tobject.Set%(field)s(%(value)s)
+    }\n""" % {"name": prop.getCIdentifierName().lower(), "field": prop.getCppName(),
+          "value": value, "member_obj": obj, "val": val}
+        return decl
+
+# ------------------- Ref Setter Snippet Object --------------------------
+    def _SnippetSetObjRef(self, ident, link_info, enable_errors=True):
+        link_to = ident.getLinkTo(link_info)
+        name = link_to.getCIdentifierName().lower()
+        data_obj = ""
+        data_getter = ""
+
+        datatype = self._getAttrType(ident, link_info)
+        if datatype:
+            data_obj = ", *dataObj"
+            data_getter = """\n\t\tdataObj := new (%(type)s)
+\t\tSet%(type)sFromMap(dataObj, d, m, (v.(map[string]interface{}))["attr"])
+\t\tlog.Printf("Data obj: %%+v", dataObj)""" %\
+                {"type": datatype, "name": name}
+
+        # TODO(KR) Value in 'for' loop is not used. This may not work at all!
+
+        if enable_errors:
+            logs_part = """\t\trefObj, err := client.FindByUuid("%(reftype)s", refId.(string))%(datagetter)s
+                  \t\tif err != nil {
+                  \t\t\treturn fmt.Errorf("[SnippetSetObjRef] Retrieving %(reftype)s by Uuid = %%v as ref for %(refname)s on %%v (%%v)", refId, client.GetServer(), err)
+                  \t\t}""" % {
+                "refname": link_to.getCppName(),
+                "reftype": link_to.getName(),
+                "datagetter": data_getter}
+
+        else:
+            logs_part = """\t\trefObj, _ := client.FindByUuid("%(reftype)s", refId.(string))%(datagetter)s""" % {
+                "reftype": link_to.getName(),
+                "datagetter": data_getter}
+
+        decl = """if val, ok := d.GetOk("%(name)s_refs"); ok {
+\tlog.Printf("Got ref %(name)s_refs -- will call: object.Add%(refname)s(refObj%(refdata)s)")
+\tfor k, v := range val.([]interface{}) {
+\t\tlog.Printf("Item: %%+v => <%%T> %%+v", k, v, v)
+\t\trefId := (v.(map[string]interface{}))["to"]
+\t\tlog.Printf("Ref 'to': %%#v (str->%%v)", refId, refId.(string))
+%(logs_part)s
+\t\tlog.Printf("Ref 'to' (OBJECT): %%+v", refObj)
+\t\tobject.Add%(refname)s(refObj.(*%(refname)s)%(refdata)s)
+\t}\n}\n""" % {
+            "name": name,
+            "refname": link_to.getCppName(),
+            "reftype": link_to.getName(),
+            "datagetter": data_getter,
+            "refdata": data_obj,
+            "logs_part": logs_part}
+        return decl
+
+# ------------------- Ref Delete Snippet Object --------------------------
+    def _SnippetDeleteObjRef(self, ident, link_info):
+        link_to = ident.getLinkTo(link_info)
+        name = link_to.getCIdentifierName().lower()
+        decl = """if val, ok := d.GetOk("%(name)s_refs"); ok {
+\tlog.Printf("Got ref %(name)s_refs -- will call: object.Delete%(refname)s(refObj.(string))")
+\tfor k, v := range val.([]interface{}) {
+\t\tlog.Printf("Item: %%+v => <%%T> %%+v", k, v, v)
+\t\trefId := (v.(map[string]interface{}))["to"]
+\t\tobject.Delete%(refname)s(refId.(string))
+\t}\n}\n""" % {
+            "name": name,
+            "refname": link_to.getCppName()}
+        return decl
+
+# ------------------- Properties Setter Object -------------------------------
+    def _GenerateSetPropertyMethods(self, ident):
+        setters = ""
+        for prop in ident.getProperties():
+            setters += self._SnippetSetObjProperty(ident.getName(), prop)
+        return setters
+
+# ------------------- Properties Setter Object -------------------------------
+    def _GenerateSetRefsMethods(self, ident, req):
+        setters = ""
+        for link_info in ident.getLinksInfo():
+            if not ident.isLinkRef(link_info):
+                continue
+
+            required = False
+            for info in link_info:
+                if isinstance(info, IFMapLink):
+                    required = ResolveOptional(info.getPresence())
+
+            if req == required:
+                setters += self._SnippetSetObjRef(ident, link_info)
+        return setters
+
+# ------------------- Properties Delete Object -------------------------------
+    def _GenerateDeleteRefsMethods(self, ident, req):
+        setters = ""
+        for link_info in ident.getLinksInfo():
+            if not ident.isLinkRef(link_info):
+                continue
+
+            required = False
+
+            for info in link_info:
+
+                if isinstance(info, IFMapLink):
+                    required = ResolveOptional(info.getPresence())
+
+            if req == required:
+                setters += self._SnippetDeleteObjRef(ident, link_info)
+        return setters
+
+# ------------------- Set From Resource Object -------------------------------
+    def _GenerateTerraformResourceSetFrom(self, ident, file):
+        decl = """
+func Set%(camel)sFromResource(object *%(name)s, d *schema.ResourceData, m interface{}, prefix ...string) {
+\tkey := strings.Join(prefix, ".")
+\tif len(key) != 0 {
+\t\tkey = key + "."
+\t}
+\tlog.Printf("[Set%(camel)sFromResource] key = %%v, prefix = %%v", key, prefix)\t\t
+%(setters)s
+}
+""" \
+        % {"camel": ident.getCppName(),
+           "setters":
+           '\t'.join(self._GenerateSetPropertyMethods(ident).splitlines(True)),
+           "name": ident.getCppName()}
+        file.write(decl)
+        # Refs
+        decl = """
+func SetRefs%(camel)sFromResource(object *%(name)s, d *schema.ResourceData, m interface{}, prefix ...string) error {
+\tkey := strings.Join(prefix, ".")
+\tif len(key) != 0 {
+\t\tkey = key + "."
+\t}
+\t%(client)s
+\tlog.Printf("[SetRefs%(camel)sFromResource] key = %%v, prefix = %%v", key, prefix)
+%(setters)s
+\treturn nil
+}
+""" \
+        % {"camel": ident.getCppName(), "setters":
+           '\t'.join(self._GenerateSetRefsMethods(ident, False).splitlines(True)),
+           "client": self._SnippetGetClient(),
+           "name": ident.getCppName()}
+        file.write(decl)
+
+
+        decl = """
+
+func SetReqRefs%(camel)sFromResource(object *%(name)s, d *schema.ResourceData, m interface{}, prefix ...string) error {
+\tkey := strings.Join(prefix, ".")
+\tif len(key) != 0 {
+\t\tkey = key + "."
+\t}
+\t%(client)s
+\tlog.Printf("[SetRefs%(camel)sFromResource] key = %%v, prefix = %%v", key, prefix)
+%(setters)s
+\treturn nil
+}
+    """ \
+               % {"camel": ident.getCppName(), "setters":
+            '\t'.join(self._GenerateSetRefsMethods(ident, True).splitlines(True)),
+                  "client": self._SnippetGetClient(),
+                  "name": ident.getCppName()}
+        if '\t'.join(self._GenerateSetRefsMethods(ident, True).splitlines(True)):
+            file.write(decl)
+
+# ------------------- Delete From Resource Object ---------------------------
+    def _GenerateTerraformResourceDeleteFrom(self, ident, file):
+        # Refs
+        decl = """
+    func DeleteRefs%(camel)sFromResource(object *%(name)s, d *schema.ResourceData, m interface{}, prefix ...string) error {
+    \tkey := strings.Join(prefix, ".")
+    \tif len(key) != 0 {
+    \t\tkey = key + "."
+    \t}
+    \t%(client)s
+    \tlog.Printf("[DeleteRefs%(camel)sFromResource] key = %%v, prefix = %%v", key, prefix)
+    %(setters)s
+    \treturn nil
+    }
+    """ \
+               % {"camel": ident.getCppName(), "setters":
+            '\t'.join(self._GenerateDeleteRefsMethods(ident, False).splitlines(True)),
+                  "client": self._SnippetGetClient(),
+                  "name": ident.getCppName()}
+        file.write(decl)
+
+    # ------------------- Property Writer Snippet Object ------------------------
+    def _SnippetMapObjProperty(self, ident_name,  prop):
+        setter = ""
+        if ("%s-%s" % (ident_name, "id")) != prop.getName():
+            gotype = prop.getGoLangTypename()
+            is_pod = IsPodType(gotype)
+            setter = "omap[\"%(name)s\"] = object.Get%(field)s()\n" % {
+                "name": prop.getCIdentifierName().lower(),
+                "field": prop.getCppName()}
+            if not is_pod:
+                setter = """%(name)sObj := object.Get%(field)s()
+    omap[\"%(name)s\"] = Take%(member)sAsMap(&%(name)sObj)\n""" % {
+                    "name": prop.getCIdentifierName().lower(),
+                    "field": prop.getCppName(),
+                    "member": gotype}
+        return setter
+
+# ------------------- Properties Mapper Object -------------------------------
+    def _SnippetMapObjProperties(self, ident):
+        writers = "\n"
+        for prop in ident.getProperties():
+            writers += self._SnippetMapObjProperty(ident.getName(), prop)
+        return writers
+
+# ------------------- Property Writer Snippet Object ------------------------
+    def _SnippetWriteObjProperty(self, ident_name, prop):
+        setter = ""
+        if ("%s-%s" % (ident_name, "id")) != prop.getName():
+            gotype = prop.getGoLangTypename()
+            is_pod = IsPodType(gotype)
+            setter = "d.Set(\"%(name)s\", object.Get%(field)s())\n" % {
+                "name": prop.getCIdentifierName().lower(),
+                "field": prop.getCppName()}
+            if not is_pod:
+                setter = """%(name)sObj := object.Get%(field)s()
+    d.Set(\"%(name)s\", Take%(member)sAsMap(&%(name)sObj))\n""" % {
+                    "name": prop.getCIdentifierName().lower(),
+                    "field": prop.getCppName(),
+                    "member": gotype}
+        return setter
+
+# ------------------- Properties Writer Object -------------------------------
+    def _SnippetWriteObjProperties(self, ident):
+        writers = "\n"
+        for prop in ident.getProperties():
+            writers += self._SnippetWriteObjProperty(ident.getName(), prop)
+        writers += self._GenerateWriteResourceRefsMethod(ident, True)
+        return writers
+
+    # ------------------- Properties Writer Refs Object --------------------------
+    def _SnippetWriteObjRefProperty(self, ident, link_info):
+        link_to = ident.getLinkTo(link_info)
+        decl = """
+          if ref, err := object.Get%(camel)sRefs(); err != nil {
+            var refList []interface{}
+            for _, v := range ref {
+                omap := make(map[string]interface{})
+                omap["to"] = v.Uuid
+                refList = append(refList, omap)
+            }
+            d.Set("%(name)s_refs", refList)
+        }""" % {"camel": link_to.getCppName(), "name": link_to.getCIdentifierName().lower()}
+        return decl
+
+
+# ------------------- Write To Resource Object -------------------------------
+    def _GenerateTerraformResourceWriteTo(self, ident, file):
+        decl = """
+func Write%(camel)sToResource(object %(name)s, d *schema.ResourceData, m interface{}) {
+%(writers)s
+}
+""" % {"camel": ident.getCppName(), "client": self._SnippetGetClient(),
+               "writers": '\t'.join(self._SnippetWriteObjProperties(
+                   ident).splitlines(True)), "name": ident.getCppName()}
+        file.write(decl)
+
+        decl = """
+func Write%(camel)sRefsToResource(object %(name)s, d *schema.ResourceData, m interface{}) {
+%(writers)s
+}
+""" % {"camel": ident.getCppName(), "client": self._SnippetGetClient(),
+               "writers": '\t'.join(self._GenerateWriteResourceRefsMethod(
+                   ident, False).splitlines(True)), "name": ident.getCppName()}
+        file.write(decl)
+
+        decl = """
+func Take%(camel)sAsMap(object *%(name)s) map[string]interface{} {
+\tomap := make(map[string]interface{})
+%(writers)s
+\treturn omap
+}
+""" % {"camel": ident.getCppName(), "client": self._SnippetGetClient(),
+               "writers": '\t'.join(self._SnippetMapObjProperties(
+                   ident).splitlines(True)), "name": ident.getCppName()}
+        file.write(decl)
+
+# ------------------- Properties Update Refs Object -------------------------------
+    def _GenerateUpdateRefsMethods(self, ident, req=False):
+        setters = ""
+        for link_info in ident.getLinksInfo():
+            if not ident.isLinkRef(link_info):
+                continue
+
+            required = False
+            for info in link_info:
+                if isinstance(info, IFMapLink):
+                    required = ResolveOptional(info.getPresence())
+
+            if req == required:
+                setters += """\t if d.HasChange(\"%(name)s_refs\") {\n\t object.Clear%(refname)s()\n\t%(setter)s}\n""" \
+                           % {"name": ident.getLinkTo(link_info).getCIdentifierName().lower(),
+                              "refname": ident.getLinkTo(link_info).getCppName(),
+                              "setter": self._SnippetSetObjRef(ident, link_info, enable_errors=False)}
+
+        return setters
+
+# ------------------- Write To Refs Resource Object -------------------------------
+    def _GenerateWriteResourceRefsMethod(self, ident, req):
+        setters = ""
+        for link_info in ident.getLinksInfo():
+            if not ident.isLinkRef(link_info):
+                continue
+
+            required = False
+            for info in link_info:
+                if isinstance(info, IFMapLink):
+                    required = ResolveOptional(info.getPresence())
+
+            if req == required:
+                setters += self._SnippetWriteObjRefProperty(ident, link_info)
+        return setters
+
+# ------------------- Create Object -------------------------------
+    def _GenerateTerraformResourceCreate(self, ident, need_refs, file):
+        decl = """
+func %(camel)sCreate(d *schema.ResourceData, m interface{}) error {
+\t// SPEW
+\tlog.Printf("%(camel)sCreate")
+\tlog.Print(spew.Sdump(d))
+\t// SPEW
+\t%(client)s
+\tobject := new(%(type)s)
+\tobject.SetName(d.Get("name").(string))
+\tif puuid_obj, ok := d.GetOk("parent_uuid"); ok {
+\t\tpuuid := puuid_obj.(string)
+\t\tparent, err := client.FindByUuid(object.GetDefaultParentType(), puuid)
+\t\tif err != nil {
+\t\t\treturn fmt.Errorf("[%(camel)sCreate] retrieving Parent with uuid %%s of type %%s for resource %%s (%%s) - on %%v (%%v)", puuid, object.GetDefaultParentType(), d.Get("name"), "%(type)s", client.GetServer(), err)
+\t\t}
+\t\tobject.SetParent(parent)
+\t}
+\t//object.SetFQName(object.GetDefaultParentType(), strings.Split(d.Get("parent_fq_name").(string) + ":" + d.Get("name").(string), ":"))
+\tSet%(type)sFromResource(object, d, m)
+%(reqRefs)s
+\tif err := client.Create(object); err != nil {
+\t\treturn fmt.Errorf("[%(camel)sCreate] Creation of resource %(type)s on %%v: (%%v)", client.GetServer(), err)
+\t}
+\td.SetId(object.GetUuid())
+\treturn nil
+}
+""" \
+        % {"camel": ResName(ident.getCppName()),
+           "client": self._SnippetGetClient(),
+           "reqRefs": self._GetRequirementSetter(ident),
+           "type": ident.getCppName()}
+        file.write(decl)
+
+        decl = """
+func %(camel)sRefsCreate(d *schema.ResourceData, m interface{}) error {
+\t// SPEW
+\tlog.Printf("%(camel)sRefsCreate")
+\t//log.Printf("SPEW: %%v", spew.Sdump(d))
+\t// SPEW
+
+\t%(client)s
+\tuuid_obj, ok := d.GetOk("uuid")
+\tif ok == false {
+\t\treturn fmt.Errorf("[%(camel)sRefsCreate] Missing 'uuid' field for resource %(type)s")
+\t}
+\tuuid := uuid_obj.(string)
+\tobj, err := client.FindByUuid("%(resname)s", uuid)
+\tif err != nil {
+\t\treturn fmt.Errorf("[%(camel)sRefsCreate] Retrieving %(type)s with uuid %%s on %%v (%%v)", uuid, client.GetServer(), err)
+\t}
+\tobj%(type)s := obj.(*%(type)s) // Fully set by Contrail backend
+\tif err := SetRefs%(type)sFromResource(obj%(type)s, d, m); err != nil {
+\t\treturn fmt.Errorf("[%(camel)sRefsCreate] Set refs on object %(type)s (uuid: %%v) on %%v (%%v)", uuid, client.GetServer(), err)
+\t}
+\tlog.Printf("Object href: %%v", obj%(type)s.GetHref())
+\tif err := client.Update(obj%(type)s); err != nil {
+\t\treturn fmt.Errorf("[%(camel)sRefsCreate] Update refs for resource %(type)s (uuid: %%v) on %%v (%%v)", uuid, client.GetServer(), err)
+\t}
+\td.SetId(obj%(type)s.GetUuid())
+\treturn nil
+}
+""" \
+        % {"camel": ResName(ident.getCppName()),
+           "client": self._SnippetGetClient(),
+           "resname": ident.getName(),
+           "ref": ident.getCIdentifierName().lower() + '_refs',
+           "type": ident.getCppName()}
+        file.write(decl)
+
+    def _GetRequirementSetter(self, ident):
+        answer = ""
+
+        for links in ident.getLinksInfo():
+            if not ident.isLinkRef(links):
+                continue
+            for link in links:
+
+                if isinstance(link, IFMapLink) and ResolveOptional(link.getPresence()):
+                    answer = """
+    \tif err := SetReqRefs%(type)sFromResource(object, d, m); err != nil {
+    \t\treturn fmt.Errorf("[%(camel)sReqRefsCreate] Set required refs on object %(type)s on %%v (%%v)", client.GetServer(), err)
+    \t}
+    """ \
+          % {"camel": ResName(ident.getCppName()),
+             "type":  ident.getCppName()}
+
+        return answer
+
+
+# ------------------- Read Object -------------------------------
+    def _GenerateTerraformResourceRead(self, ident, need_refs, file):
+        decl = """
+func %(camel)sRead(d *schema.ResourceData, m interface{}) error {
+\tlog.Printf("%(camel)sRead")
+\t%(client)s
+\tbase, err := client.FindByUuid("%(typename)s", d.Id())
+\tif err != nil {
+\t\treturn fmt.Errorf("[%(camel)sRead] Read resource %(typename)s on %%v: (%%v)", client.GetServer(), err)
+\t}
+\tobject := base.(*%(type)s)
+\tWrite%(type)sToResource(*object, d, m)
+\treturn nil
+}
+""" \
+        % {"camel": ResName(ident.getCppName()),
+           "client": self._SnippetGetClient(),
+           "type": ident.getCppName(),
+           "typename": ident.getName()}
+        file.write(decl)
+
+        decl = """
+func %(camel)sRefsRead(d *schema.ResourceData, m interface{}) error {
+\tlog.Printf("%(camel)sRefsRead")
+\t%(client)s
+\tbase, err := client.FindByUuid("%(typename)s", d.Id())
+\tif err != nil {
+\t\treturn fmt.Errorf("[%(camel)sRefsRead] Read resource %(typename)s on %%v: (%%v)", client.GetServer(), err)
+\t}
+\tobject := base.(*%(type)s)
+\tWrite%(type)sRefsToResource(*object, d, m)
+\treturn nil
+}
+""" \
+        % {"camel": ResName(ident.getCppName()),
+           "client": self._SnippetGetClient(),
+           "type": ident.getCppName(),
+           "typename": ident.getName()}
+        file.write(decl)
+
+# ------------------- Properties Updater Object -------------------------------
+    def _SnippetUpdateObjProperties(self, ident):
+        updaters = "\n"
+        for prop in ident.getProperties():
+            if ("%s-%s" % (ident.getName(), "id")) != prop.getName():
+                updaters += "if d.HasChange(\"%(name)s\") {\n\t%(setter)s}\n" % {
+                    "setter": self._SnippetSetObjProperty(ident.getName(), prop),
+                    "name": prop.getCIdentifierName().lower()}
+
+        refs_update = self._GenerateUpdateRefsMethods(ident, True)
+        if refs_update:
+            updaters += """
+\tclient := m.(*contrail.Client)
+\tclient.GetServer() // dummy call
+""" + refs_update
+        return updaters
+
+    def _SnippetUpdateObjRefsProperties(self, ident):
+        updaters ="""
+\tclient := m.(*contrail.Client)
+\tclient.GetServer() // dummy call
+"""
+        return updaters + self._GenerateUpdateRefsMethods(ident, False)
+
+# ------------------- Update From Resource Object -----------------------------
+    def _GenerateTerraformResourceUpdateFrom(self, ident, file):
+        decl = """
+func Update%(camel)sFromResource(object *%(name)s, d *schema.ResourceData, m interface{}, prefix ...string) {
+\tkey := strings.Join(prefix, ".")
+\tif len(key) != 0 {
+\t\tkey = key + "."
+\t}
+%(setters)s
+}
+        """ % {"camel": ident.getCppName(), "setters":
+               '\t'.join(self._SnippetUpdateObjProperties(
+                   ident).splitlines(True)),
+               "name": ident.getCppName()}
+
+        file.write(decl)
+        decl = """
+func Update%(camel)sRefsFromResource(object *%(name)s, d *schema.ResourceData, m interface{}, prefix ...string) {
+\tkey := strings.Join(prefix, ".")
+\tif len(key) != 0 {
+\t\tkey = key + "."
+\t}
+%(setters)s
+}
+        """ % {"camel": ident.getCppName(), "setters":
+               '\t'.join(self._SnippetUpdateObjRefsProperties(
+                   ident).splitlines(True)),
+               "name": ident.getCppName()}
+        file.write(decl)
+
+# ------------------- Update Object -------------------------------
+    def _GenerateTerraformResourceUpdate(self, ident, need_refs, file):
+        decl = """
+func %(camel)sUpdate(d *schema.ResourceData, m interface{}) error {
+\tlog.Printf("%(camel)sUpdate")
+\t%(client)s
+\tobj, err := client.FindByUuid("%(resname)s", d.Id())
+\tif err != nil {
+\t\treturn fmt.Errorf("[%(camel)sUpdate] Retrieving %(type)s with uuid %%s on %%v (%%v)", d.Id(), client.GetServer(), err)
+\t}
+\tuobject := obj.(*%(type)s)
+\tUpdate%(type)sFromResource(uobject, d, m)
+
+\tlog.Printf("Object href: %%v", uobject.GetHref())
+\tif err := client.Update(uobject); err != nil {
+\t\treturn fmt.Errorf("[%(camel)sUpdate] Update of resource %(type)s on %%v: (%%v)", client.GetServer(), err)
+\t}
+\treturn nil
+}
+""" \
+        % {"camel": ResName(ident.getCppName()),
+           "client": self._SnippetGetClient(),
+           "resname": ident.getName(),
+           "type": ident.getCppName()}
+        file.write(decl)
+
+        decl = """
+func %(camel)sRefsUpdate(d *schema.ResourceData, m interface{}) error {
+\tlog.Printf("%(camel)sRefsUpdate")
+\t%(client)s
+\tobj, err := client.FindByUuid("%(resname)s", d.Id())
+\tif err != nil {
+\t\treturn fmt.Errorf("[%(camel)sRefsUpdate] Retrieving %(type)s with uuid %%s on %%v (%%v)", d.Id(), client.GetServer(), err)
+\t}
+\tuobject := obj.(*%(type)s)
+\tUpdate%(type)sRefsFromResource(uobject, d, m)
+
+\tlog.Printf("Object href: %%v", uobject.GetHref())
+\tif err := client.Update(uobject); err != nil {
+\t\treturn fmt.Errorf("[%(camel)sRefsUpdate] Update of resource %(type)s on %%v: (%%v)", client.GetServer(), err)
+\t}
+\treturn nil
+}
+""" \
+        % {"camel": ResName(ident.getCppName()),
+           "client": self._SnippetGetClient(),
+           "resname": ident.getName(),
+           "type": ident.getCppName()}
+        file.write(decl)
+
+
+# ------------------- Delete Object -------------------------------
+    def _GenerateTerraformResourceDelete(self, ident, need_refs, file):
+            decl = """
+    func %(camel)sDelete(d *schema.ResourceData, m interface{}) error {
+    \tlog.Printf("%(camel)sDelete: %%v", d.Id())
+    \t%(client)s
+    \tif err := client.DeleteByUuid("%(typename)s", d.Id()); err != nil {
+    \t\treturn fmt.Errorf("[%(camel)sDelete] Deletion of resource %(typename)s on %%v: (%%v)", client.GetServer(), err)
+    \t}
+    \td.SetId("")
+    \treturn nil
+    }
+    """ % {"camel": ResName(ident.getCppName()),
+           "client": self._SnippetGetClient(), "typename": ident.getName()}
+            file.write(decl)
+
+            decl = """
+    func %(camel)sRefsDelete(d *schema.ResourceData, m interface{}) error {
+    \t// SPEW
+    \tlog.Printf("%(camel)sRefsDelete")
+    \t//log.Printf("SPEW: %%v", spew.Sdump(d))
+    \t// SPEW
+
+    \t%(client)s
+    \tuuid_obj, ok := d.GetOk("uuid")
+    \tif ok == false {
+    \t\treturn fmt.Errorf("[%(camel)sRefsDelete] Missing 'uuid' field for resource %(type)s")
+    \t}
+    \tuuid := uuid_obj.(string)
+    \tobj, err := client.FindByUuid("%(resname)s", uuid)
+    \tif err != nil {
+    \t\treturn fmt.Errorf("[%(camel)sRefsDelete] Retrieving %(type)s with uuid %%s on %%v (%%v)", uuid, client.GetServer(), err)
+    \t}
+    \tobj%(type)s := obj.(*%(type)s) // Fully set by Contrail backend
+    \tif err := DeleteRefs%(type)sFromResource(obj%(type)s, d, m); err != nil {
+    \t\treturn fmt.Errorf("[%(camel)sRefsDelete] Set refs on object %(type)s (uuid: %%v) on %%v (%%v)", uuid, client.GetServer(), err)
+    \t}
+    \tlog.Printf("Object href: %%v", obj%(type)s.GetHref())
+    \tif err := client.Update(obj%(type)s); err != nil {
+    \t\treturn fmt.Errorf("[%(camel)sRefsDelete] Delete refs for resource %(type)s (uuid: %%v) on %%v (%%v)", uuid, client.GetServer(), err)
+    \t}
+    \td.SetId(obj%(type)s.GetUuid())
+    \treturn nil
+    }
+            """ \
+                   % {"camel": ResName(ident.getCppName()),
+                      "client": self._SnippetGetClient(),
+                      "resname": ident.getName(),
+                      "ref": ident.getCIdentifierName().lower() + '_refs',
+                      "type": ident.getCppName()}
+            file.write(decl)
+
+# ------------------- Generate (public method) -------------------------------
+    def Generate(self, dirname):
+        if not os.path.exists(dirname):
+            os.makedirs(dirname)
+        elif not os.path.isdir(dirname):
+            print "-o option must specify directory"
+            sys.exit(1)
+
+        self._GenerateTypeMap(dirname)
+        for ident in self._identifier_map.values():
+            fname = os.path.join(dirname, ident.getCIdentifierName() + ".go")
+            self._GenerateObject(ident, fname)
+
+        self._PromoteInnerTypes()
+        for ctype in self._top_level_map.values():
+            fname = os.path.join(dirname, ctype.getCIdentifierName() + ".go")
+            self._GenerateStructType(ctype, fname)
+
+        # Reference docs
+        self._GenerateDocfile(dirname)
+
+    def _PromoteInnerTypes(self):
+        inner_type_map = {}
+
+        for ctype in self._top_level_map.values():
+            self._ExamineInnerTypes(inner_type_map, ctype, ctype)
+
+        while True:
+            promoted = []
+            for itype, typeset in inner_type_map.iteritems():
+                if len(typeset) == 1:
+                    continue
+                self._top_level_map[itype] = self._type_map[itype]
+                promoted.append(itype)
+
+            if len(promoted) == 0:
+                break
+
+            for itype in promoted:
+                del inner_type_map[itype]
+                ctype = self._type_map[itype]
+                self._ExamineInnerTypes(inner_type_map, ctype, ctype)
+
+    def _ExamineInnerTypes(self, inner_type_map, top_level, ctype):
+        """ Examine all the dependent types of a given top_level type
+        (recursivly) in order to determine which types are referred to
+        more than once.
+        The ones that are get promoted to top-level.
+        """
+        for deptype in ctype.getDependentTypes():
+            mtype = deptype.getName()
+            if mtype in inner_type_map:
+                xset = inner_type_map[mtype]
+                if top_level not in xset:
+                    xset.append(top_level)
+            else:
+                inner_type_map[mtype] = [top_level]
+
+            self._ExamineInnerTypes(inner_type_map, top_level, deptype)
+
+    def _IdentifierLinks(self, ident):
+        """ Returns the list of all the links (children, refs, back_refs)
+        of a specific identifier.
+        """
+        fields = []
+        for link_info in ident.getLinksInfo():
+            if ident.isLinkRef(link_info):
+                suffix = '_refs'
+            elif ident.isLinkHas(link_info):
+                suffix = 's'
+            else:
+                suffix = '_refs'
+            link_to = ident.getLinkTo(link_info)
+            fields.append(link_to.getCIdentifierName() + suffix)
+        for back_link in ident.getBackLinksInfo():
+            link_from = ident.getBackLinkFrom(back_link)
+            fields.append(link_from.getCIdentifierName() + '_back_refs')
+
+        return fields
-- 
2.17.1

